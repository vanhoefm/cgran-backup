/* -*- c++ -*- */
/*
 * Copyright 2010 Karlsruhe Institute of Technology, Communications Engineering Lab
 * 
 * 
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 * 
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <linalg_svd_decomposer.h>
#include <algorithm>
#include <cstdio>

/*
 * Create a new instance of linalg_svd_decomposer and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
linalg_svd_decomposer_sptr 
linalg_make_svd_decomposer (size_t M, size_t N)
{
  return linalg_svd_decomposer_sptr (new linalg_svd_decomposer (M,N));
}

linalg_svd_decomposer::linalg_svd_decomposer (size_t M, size_t N) : d_M(M), d_N(N)
{
  d_LDA = std::max(size_t(1), M);                                                                                     

  /* setup the array S */
  d_S = new double[std::min(M,N)];

  /* setup the array U */
  d_LDU = M;
  d_mat_U = new gr_complexd[d_LDU*std::min(M,N)];

  /* setup the array VT */
  d_LDVT = std::min(M,N);
  d_mat_VT = new gr_complexd[d_LDVT*N];

  /* setup internal stuff */
  d_RWORK = new double[5*std::min(M,N)*std::min(M,N) + 7*std::min(M,N)];
  d_IWORK = new int[8*std::min(M,N)];
  
  /* determine optimal workspace size */
  gr_complexd tmpwork;
  size_t tmpworksize = -1;
  char jobz = 'S';
  zgesdd_ (&jobz, &M, &N, d_mat_A, &d_LDA, d_S, d_mat_U, &d_LDU, d_mat_VT, &d_LDVT,
           &tmpwork, &tmpworksize, d_RWORK, d_IWORK, &d_INFO);
  d_LWORK = static_cast<size_t> (std::ceil(tmpwork.real()));
  d_WORK = new gr_complexd[d_LWORK];

}

linalg_svd_decomposer::~linalg_svd_decomposer ()
{
  delete[] d_S;
  delete[] d_mat_U;
  delete[] d_mat_VT;
  delete[] d_RWORK;
  delete[] d_IWORK;
  delete[] d_WORK;
}

void
linalg_svd_decomposer::set_matrix (gr_complexd* mat_A)
{
  d_mat_A = mat_A;
}

void
linalg_svd_decomposer::decompose ()
{
  char jobz = 'S';
  zgesdd_ (&jobz, &d_M, &d_N, d_mat_A, &d_LDA, d_S, d_mat_U, &d_LDU, d_mat_VT, &d_LDVT,
           d_WORK, &d_LWORK, d_RWORK, d_IWORK, &d_INFO);
}

double*
linalg_svd_decomposer::S()
{
  return d_S;
}

linalg_svd_decomposer_no_vt_sptr 
linalg_make_svd_decomposer_no_vt (size_t M, size_t N)
{
  return linalg_svd_decomposer_no_vt_sptr (new linalg_svd_decomposer_no_vt (M,N));
}

linalg_svd_decomposer_no_vt::linalg_svd_decomposer_no_vt (size_t M, size_t N) : d_M(M), d_N(N)
{
  d_LDA = std::max(size_t(1), M);                                                                                     
  /* setup the array S */
  d_S = new double[std::min(M,N)];

  /* setup the array U */
  d_LDU = M;
  d_mat_U = new gr_complexd[d_LDU*std::min(M,N)];

  /* setup the array VT */
  d_LDVT = 1; // d_LDVT has to be >= 1
  d_mat_VT = NULL; // we don't care for VT

  /* setup internal stuff */
  d_RWORK = new double[5*std::min(M,N)];
  
  /* determine optimal workspace size */
  gr_complexd tmpwork;
  size_t tmpworksize = -1;
  char jobu = 'S'; // do economy size svd
  char jobvt = 'N';  // we don't need VT
  zgesvd_ (&jobu, &jobvt, &M, &N, d_mat_A, &d_LDA, d_S, d_mat_U, &d_LDU, d_mat_VT, &d_LDVT,
           &tmpwork, &tmpworksize, d_RWORK, &d_INFO);
  d_LWORK = static_cast<size_t> (std::ceil(tmpwork.real()));
  d_WORK = new gr_complexd[d_LWORK];

}

linalg_svd_decomposer_no_vt::~linalg_svd_decomposer_no_vt ()
{
  delete[] d_S;
  delete[] d_mat_U;
  delete[] d_RWORK;
  delete[] d_WORK;
}

void
linalg_svd_decomposer_no_vt::decompose ()
{
  char jobu = 'S';
  char jobvt = 'N';
  zgesvd_ (&jobu, &jobvt, &d_M, &d_N, d_mat_A, &d_LDA, d_S, d_mat_U, &d_LDU, d_mat_VT, &d_LDVT,
           d_WORK, &d_LWORK, d_RWORK, &d_INFO);
}

double*
linalg_svd_decomposer_no_vt::S ()
{
  return d_S;
}

void
linalg_svd_decomposer_no_vt::set_matrix (gr_complexd* mat_A)
{
  d_mat_A = mat_A;
}
