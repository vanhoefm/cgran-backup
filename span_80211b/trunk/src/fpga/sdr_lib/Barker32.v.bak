// -------------------------------------------------------------
//
// Module: Barker32
//
// Generated by MATLAB(R) 7.0 and the Filter Design HDL Coder 1.0.
//
// Generated on: 2008-02-22 18:38:06
//
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// TargetLanguage: Verilog
// Name: Barker32
// InputPort: data_in
// OutputPort: data_out
// UseVerilogTimescale: Off
// ResetType: Sync
// InlineConfigurations: Off
// SafeZeroConcat: Off
// TestBenchStimulus: impulse step ramp chirp noise 
//
// Filter Settings:
//
// Discrete-Time FIR Filter (real)
// -------------------------------
// Filter Structure  : Direct-Form FIR
// Filter Order      : 31
// Stable            : Yes
// Linear Phase      : No
// -------------------------------------------------------------

module Barker32 (clk, clk_enable, reset, data_in, data_out );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   [63:0] data_in; //double
  output  [63:0] data_out; //double

  // Local Functions
  // Type Definitions
  // Constants
 /* parameter coeff1 = 1.0000000000000000E+000; //double
  parameter coeff2 = 5.4010000000000002E-001; //double
  parameter coeff3 = -2.8689999999999999E-001; //double
  parameter coeff4 = -9.6179999999999999E-001; //double
  parameter coeff5 = -1.0401000000000000E+000; //double
  parameter coeff6 = -3.6759999999999998E-001; //double
  parameter coeff7 = 7.8930000000000000E-001; //double
  parameter coeff8 = 1.7338000000000000E+000; //double
  parameter coeff9 = 1.9548000000000001E+000; //double
  parameter coeff10 = 1.3241000000000001E+000; //double
  parameter coeff11 = 1.7360000000000000E-001; //double
  parameter coeff12 = -7.8300000000000003E-001; //double
  parameter coeff13 = -1.0909000000000000E+000; //double
  parameter coeff14 = -6.8530000000000002E-001; //double
  parameter coeff15 = 1.2030000000000000E-001; //double
  parameter coeff16 = 7.9830000000000001E-001; //double
  parameter coeff17 = 1.1000000000000001E+000; //double
  parameter coeff18 = 1.0802000000000000E+000; //double
  parameter coeff19 = 9.9150000000000005E-001; //double
  parameter coeff20 = 1.0382000000000000E+000; //double
  parameter coeff21 = 1.1792000000000000E+000; //double
  parameter coeff22 = 1.1915000000000000E+000; //double
  parameter coeff23 = 8.5609999999999997E-001; //double
  parameter coeff24 = 2.0190000000000000E-001; //double
  parameter coeff25 = -5.3990000000000005E-001; //double
  parameter coeff26 = -1.0744000000000000E+000; //double
  parameter coeff27 = -1.2521000000000000E+000; //double
  parameter coeff28 = -1.1471000000000000E+000; //double
  parameter coeff29 = -9.8839999999999995E-001; //double
  parameter coeff30 = -9.4059999999999999E-001; //double
  parameter coeff31 = -9.9660000000000004E-001; //double
  parameter coeff32 = -1.0000000000000000E+000; //double
*/
  // Signals
  integer delay_pipeline [0:31] ; // double
  integer product32; // double
  integer product31; // double
  integer product30; // double
  integer product29; // double
  integer product28; // double
  integer product27; // double
  integer product26; // double
  integer product25; // double
  integer product24; // double
  integer product23; // double
  integer product22; // double
  integer product21; // double
  integer product20; // double
  integer product19; // double
  integer product18; // double
  integer product17; // double
  integer product16; // double
  integer product15; // double
  integer product14; // double
  integer product13; // double
  integer product12; // double
  integer product11; // double
  integer product10; // double
  integer product9; // double
  integer product8; // double
  integer product7; // double
  integer product6; // double
  integer product5; // double
  integer product4; // double
  integer product3; // double
  integer product2; // double
  integer product1; // double
  integer sum1; // double
  integer sum2; // double
  integer sum3; // double
  integer sum4; // double
  integer sum5; // double
  integer sum6; // double
  integer sum7; // double
  integer sum8; // double
  integer sum9; // double
  integer sum10; // double
  integer sum11; // double
  integer sum12; // double
  integer sum13; // double
  integer sum14; // double
  integer sum15; // double
  integer sum16; // double
  integer sum17; // double
  integer sum18; // double
  integer sum19; // double
  integer sum20; // double
  integer sum21; // double
  integer sum22; // double
  integer sum23; // double
  integer sum24; // double
  integer sum25; // double
  integer sum26; // double
  integer sum27; // double
  integer sum28; // double
  integer sum29; // double
  integer sum30; // double
  integer sum31; // double
  integer output_typeconvert; // double
  integer output_register; // double

  // Block Statements
  always @( posedge clk)
    begin: Delay_Pipeline_process
      if (reset == 1'b1) begin
        delay_pipeline[0] <= 0;
        delay_pipeline[1] <= 0;
        delay_pipeline[2] <= 0;
        delay_pipeline[3] <= 0;
        delay_pipeline[4] <= 0;
        delay_pipeline[5] <= 0;
        delay_pipeline[6] <= 0;
        delay_pipeline[7] <= 0;
        delay_pipeline[8] <= 0;
        delay_pipeline[9] <= 0;
        delay_pipeline[10] <= 0;
        delay_pipeline[11] <= 0;
        delay_pipeline[12] <= 0;
        delay_pipeline[13] <= 0;
        delay_pipeline[14] <= 0;
        delay_pipeline[15] <= 0;
        delay_pipeline[16] <= 0;
        delay_pipeline[17] <= 0;
        delay_pipeline[18] <= 0;
        delay_pipeline[19] <= 0;
        delay_pipeline[20] <= 0;
        delay_pipeline[21] <= 0;
        delay_pipeline[22] <= 0;
        delay_pipeline[23] <= 0;
        delay_pipeline[24] <= 0;
        delay_pipeline[25] <= 0;
        delay_pipeline[26] <= 0;
        delay_pipeline[27] <= 0;
        delay_pipeline[28] <= 0;
        delay_pipeline[29] <= 0;
        delay_pipeline[30] <= 0;
        delay_pipeline[31] <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_pipeline[0] <= data_in;
          delay_pipeline[1] <= delay_pipeline[0];
          delay_pipeline[2] <= delay_pipeline[1];
          delay_pipeline[3] <= delay_pipeline[2];
          delay_pipeline[4] <= delay_pipeline[3];
          delay_pipeline[5] <= delay_pipeline[4];
          delay_pipeline[6] <= delay_pipeline[5];
          delay_pipeline[7] <= delay_pipeline[6];
          delay_pipeline[8] <= delay_pipeline[7];
          delay_pipeline[9] <= delay_pipeline[8];
          delay_pipeline[10] <= delay_pipeline[9];
          delay_pipeline[11] <= delay_pipeline[10];
          delay_pipeline[12] <= delay_pipeline[11];
          delay_pipeline[13] <= delay_pipeline[12];
          delay_pipeline[14] <= delay_pipeline[13];
          delay_pipeline[15] <= delay_pipeline[14];
          delay_pipeline[16] <= delay_pipeline[15];
          delay_pipeline[17] <= delay_pipeline[16];
          delay_pipeline[18] <= delay_pipeline[17];
          delay_pipeline[19] <= delay_pipeline[18];
          delay_pipeline[20] <= delay_pipeline[19];
          delay_pipeline[21] <= delay_pipeline[20];
          delay_pipeline[22] <= delay_pipeline[21];
          delay_pipeline[23] <= delay_pipeline[22];
          delay_pipeline[24] <= delay_pipeline[23];
          delay_pipeline[25] <= delay_pipeline[24];
          delay_pipeline[26] <= delay_pipeline[25];
          delay_pipeline[27] <= delay_pipeline[26];
          delay_pipeline[28] <= delay_pipeline[27];
          delay_pipeline[29] <= delay_pipeline[28];
          delay_pipeline[30] <= delay_pipeline[29];
          delay_pipeline[31] <= delay_pipeline[30];
        end
      end
    end // Delay_Pipeline_process

  always @* product32 <= -delay_pipeline[31];

  always @* product31 <= -delay_pipeline[30];

  always @* product30 <= -delay_pipeline[29];

  always @* product29 <= -delay_pipeline[28];

  always @* product28 <= -delay_pipeline[27];

  always @* product27 <= -delay_pipeline[26];

  always @* product26 <= -delay_pipeline[25];

  always @* product25 <= delay_pipeline[24] * -5;

  always @* product24 <= delay_pipeline[23] * 2;

  always @* product23 <= delay_pipeline[22] * 8;

  always @* product22 <= delay_pipeline[21];

  always @* product21 <= delay_pipeline[20];

  always @* product20 <= delay_pipeline[19];

  always @* product19 <= delay_pipeline[18] * 10;

  always @* product18 <= delay_pipeline[17];

  always @* product17 <= delay_pipeline[16];

  always @* product16 <= delay_pipeline[15] * 8;

  always @* product15 <= delay_pipeline[14];

  always @* product14 <= delay_pipeline[13] * -7;

  always @* product13 <= -delay_pipeline[12];

  always @* product12 <= delay_pipeline[11] * -8;

  always @* product11 <= delay_pipeline[10] * 2;

  always @* product10 <= delay_pipeline[9];

  always @* product9 <= delay_pipeline[8] * 2;

  always @* product8 <= delay_pipeline[7] * 2;

  always @* product7 <= delay_pipeline[6] * 8;

  always @* product6 <= delay_pipeline[5] * -4;

  always @* product5 <= -delay_pipeline[4];

  always @* product4 <= delay_pipeline[3] * -10;

  always @* product3 <= delay_pipeline[2] * -2;

  always @* product2 <= delay_pipeline[1] * 5;

  always @* product1 <= delay_pipeline[0];


  always @* sum1 <= product1 + product2;

  always @* sum2 <= sum1 + product3;

  always @* sum3 <= sum2 + product4;

  always @* sum4 <= sum3 + product5;

  always @* sum5 <= sum4 + product6;

  always @* sum6 <= sum5 + product7;

  always @* sum7 <= sum6 + product8;

  always @* sum8 <= sum7 + product9;

  always @* sum9 <= sum8 + product10;

  always @* sum10 <= sum9 + product11;

  always @* sum11 <= sum10 + product12;

  always @* sum12 <= sum11 + product13;

  always @* sum13 <= sum12 + product14;

  always @* sum14 <= sum13 + product15;

  always @* sum15 <= sum14 + product16;

  always @* sum16 <= sum15 + product17;

  always @* sum17 <= sum16 + product18;

  always @* sum18 <= sum17 + product19;

  always @* sum19 <= sum18 + product20;

  always @* sum20 <= sum19 + product21;

  always @* sum21 <= sum20 + product22;

  always @* sum22 <= sum21 + product23;

  always @* sum23 <= sum22 + product24;

  always @* sum24 <= sum23 + product25;

  always @* sum25 <= sum24 + product26;

  always @* sum26 <= sum25 + product27;

  always @* sum27 <= sum26 + product28;

  always @* sum28 <= sum27 + product29;

  always @* sum29 <= sum28 + product30;

  always @* sum30 <= sum29 + product31;

  always @* sum31 <= sum30 + product32;

  always @* output_typeconvert <= sum31;


  always @ ( posedge clk)
    begin: Output_Register_process
      if (reset == 1'b1) begin
        output_register <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign data_out = output_register;

endmodule  // Barker32
